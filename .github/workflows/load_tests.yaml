# Uses the shared workflow from this repo for ease of maintenance
name: Load Tests

on:
  pull_request:
    paths:
      - .github/workflows/load_tests.yaml
      - gen3-load-tests/*
  workflow_dispatch:
    inputs:
      TEST_ENV:
        description: 'Test environment'
        required: false
        default: ci-perf
      TEST_SUITE:
        description: 'Load test to execute, use all to run all tests'
        required: false
        type: choice
        options:
          - TestFencePresignedURL
          - TestGa4ghDrsPerformance
          - TestIndexdCreateRecords
          - TestIndexdDrsEndpoint
          - TestMetadataCreateAndQuery
          - TestSheepdogImportClinicalMetadata
          - ALL
        default: ALL
      RELEASE_VERSION:
        description: 'Release version'
        required: true

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

jobs:
    setup:
      runs-on: ubuntu-latest
      outputs:
        TEST_ENV: ${{ steps.setvars.outputs.TEST_ENV }}
        TEST_SUITE: ${{ steps.setvars.outputs.TEST_SUITE }}
        RELEASE_VERSION: ${{ steps.setvars.outputs.RELEASE_VERSION }}
      steps:
        - name: Determine TEST_ENV, TEST_SUITE and RELEASE_VERSION
          id: setvars
          run: |
            # Determine values based on trigger
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              TEST_ENV="${{ github.event.inputs.TEST_ENV }}"
              TEST_SUITE="${{ github.event.inputs.TEST_SUITE }}"
              RELEASE_VERSION="${{ github.event.inputs.RELEASE_VERSION }}"
            else
              TEST_ENV="jenkins-perf"
              TEST_SUITE="ALL"
              RELEASE_VERSION="master"
            fi

            echo "TEST_ENV=$TEST_ENV" >> $GITHUB_OUTPUT
            echo "TEST_SUITE=$TEST_SUITE" >> $GITHUB_OUTPUT
            echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_OUTPUT
    load_tests:
        runs-on: ubuntu-latest
        needs: setup

        defaults:
          run:
            # the test directory in gen3-code-vigil
            working-directory: gen3-load-tests

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          JENKINS_URL: "https://jenkins.planx-pla.net"
          JENKINS_USERNAME: "PlanXCyborg"
          JENKINS_PASSWORD: ${{ secrets.JENKINS_API_TOKEN }}
          REPO: ${{ github.event.repository.name }}
          REPO_FN: ${{ github.event.repository.full_name }}
          BRANCH: ${{ github.event.pull_request.head.ref }}
          PR_NUM: ${{ github.event.pull_request.number }}
          RUN_NUM: ${{ github.run_number }}
          SLACK_CHANNEL: ${{ secrets.CI_SLACK_CHANNEL_ID }}
          MTLS_CRT: ${{ secrets.MTLS_CRT }}
          MTLS_KEY: ${{ secrets.MTLS_KEY }}
          TEST_SUITE: ${{ needs.setup.outputs.TEST_SUITE }}
          NAMESPACE: ${{ needs.setup.outputs.TEST_ENV }}
          RELEASE_VERSION: ${{ needs.setup.outputs.RELEASE_VERSION }}
          EKS_CLUSTER_NAME : ${{ secrets.EKS_CLUSTER_NAME }}
          QA_DASHBOARD_S3_PATH: ${{ secrets.QA_DASHBOARD_S3_PATH }}


        steps:
          # Ensure the PR is run under the same org as an Internal PR
          # and not by external forks/PRs
          - name: Check if PR is from the same organization
            if: github.repository_owner != github.event.pull_request.head.repo.owner.login
            run:  |
              echo "Skip pull requests from repositories not within the same organization"
              echo "SKIP_TESTS=true" >> $GITHUB_ENV

          # Checkout master branch of gen3-code-vigil when another repo is under test
          - name: Checkout integration test code
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: actions/checkout@v4
            with:
              repository: uc-cdis/gen3-code-vigil
              ref: ${{ inputs.TEST_REPO_BRANCH }}

          # Checkout gen3-gitops repo
          - name: Checkout gen3-gitops repo
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: actions/checkout@v4
            with:
              repository: uc-cdis/gen3-gitops
              ref: 'master'
              path: gen3-gitops-ci

          - name: Get commit time
            if: ${{ env.SKIP_TESTS != 'true' }}
            run: |
              commit_time=$(gh api repos/$REPO_FN/commits/$COMMIT_SHA | jq -r '.commit.committer.date')
              echo "COMMIT_TIME=$commit_time" >> $GITHUB_ENV

          # gen3-integration-tests run with python 3.9
          - name: Set up Python
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: actions/setup-python@v5
            with:
              python-version: '3.9'

          - name: Set up Go
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: actions/setup-go@v5
            with:
              go-version: '1.17'

          # allure report generation needs node
          - name: Set up node
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: actions/setup-node@v4
            with:
              node-version: 20

          # Setup kubectl
          - name: Set Up kubectl
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: azure/setup-kubectl@v3
            with:
              version: latest

          # Setup helm
          - name: Set Up Helm
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: azure/setup-helm@v4.3.0
            with:
              version: latest

          - name: Install dependencies
            if: ${{ env.SKIP_TESTS != 'true' }}
            env:
              YQ_VERSION: v4.45.2
              YQ_BINARY: yq_linux_amd64
            run: |
              sudo rm -f /etc/apt/sources.list.d/github_git-lfs.list
              sudo apt update && sudo apt install wget -y
              sudo wget https://raw.githubusercontent.com/dwyl/english-words/master/words.txt -O /usr/share/dict/words
              sudo wget https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${YQ_BINARY}.tar.gz -O - |\
              tar xz && sudo mv ${YQ_BINARY} /usr/bin/yq
              python -m pip install --upgrade pip
              if [[ "$REPO" == "data-simulator" ]]; then
                sed -i "s|\(data-simulator[[:space:]]*=[[:space:]]*{[^}]*rev[[:space:]]*=[[:space:]]*\"\)[^\"]*\(.*\)|\1$BRANCH\2|" pyproject.toml
              fi
              pip install poetry
              poetry lock
              poetry install
              poetry show
              sudo apt update && poetry run playwright install-deps && poetry run playwright install --with-deps chromium
              sudo apt install openjdk-11-jre -y
              sudo gpg -k
              sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
              echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
              sudo apt-get update
              sudo apt-get install k6

          # Configure credentials to access cluster.
          - name: Configure AWS Credentials
            if: ${{ env.SKIP_TESTS != 'true' }}
            uses: aws-actions/configure-aws-credentials@v3
            with:
                role-to-assume: arn:aws:iam::707767160287:role/github-action-role
                role-session-name: GitHub_to_AWS_via_FederatedOIDC
                aws-region: "us-east-1"
                role-duration-seconds: 7200

          # Create kubeconfig to point at cluster.
          - name: Update kube config
            if: ${{ env.SKIP_TESTS != 'true' }}
            run: |
              aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region "us-east-1"
            env:
              EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}

          # Create PR namespace and PR hostname env var
          - name: Create namespace and env vars
            if: ${{ env.SKIP_TESTS != 'true' }}
            # Change the HOSTNAME with full domain name
            run: |
              NAMESPACE=ci-perf
              HOSTNAME=perf.ci.planx-pla.net
              echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
              echo "HOSTNAME=$HOSTNAME" >> $GITHUB_ENV
              kubectl create namespace $NAMESPACE || true

          - name: Prepare CI environment
            id: prep_ci_env
            if: ${{ env.SKIP_TESTS != 'true' }}
            continue-on-error: true  # if this fails, we still need to run clean-up steps
            run: |
              echo $UPDATED_FOLDERS
              mkdir $HOME/.gen3
              poetry run python -m gen3_ci.scripts.prepare_ci_environment
              if [ $? -ne 0 ]; then
                echo "PR_ERROR_MSG=Failed to Prepare CI environment" >> $GITHUB_ENV
              fi

          - name: Run tests
            id: run_tests
            if: ${{ env.SKIP_TESTS != 'true' && steps.prep_ci_env.outcome == 'success' }}
            continue-on-error: true  # if this fails, we still need to run clean-up steps
            env:
              TEST_SUITE: ${{ env.TEST_SUITE }}
            run: |
              mkdir output
              if [[ "${TEST_SUITE}" == "ALL" ]]; then
                echo "Running full test suite..."
                GEN3_INSTANCE_TYPE="HELM_LOCAL" poetry run pytest -n 1 -m "not wip" --alluredir allure-results --no-header --dist loadscope
              else
                echo "Running only: $TEST_SUITE"
                GEN3_INSTANCE_TYPE="HELM_LOCAL" poetry run pytest -n 1 -m "not wip" --alluredir allure-results --no-header --dist loadscope -k "$TEST_SUITE"
              fi

              if [ $? -ne 0 ]; then
                echo "PR_ERROR_MSG=Test(s) failures encountered in PR" >> $GITHUB_ENV
              fi

          - name: Generate allure report
            id: generate_allure_report
            if: ${{ env.SKIP_TESTS != 'true' && steps.run_tests.outcome == 'success' || steps.run_tests.outcome == 'failure' }}
            continue-on-error: true  # if this fails, we still need to run clean-up steps
            run: |
              npm install -g allure-commandline --save-dev
              allure generate allure-results -o allure-report --clean
              if [ $? -ne 0 ]; then
                echo "PR_ERROR_MSG=Failed to generate allure report" >> $GITHUB_ENV
              fi

          - name: Upload allure report to S3
            id: upload_allure_report
            if: ${{ env.SKIP_TESTS != 'true' && steps.generate_allure_report.outcome == 'success' }}
            continue-on-error: true  # if this fails, we still need to run clean-up steps
            run: |
              aws s3 sync ./allure-report ${{ secrets.QA_DASHBOARD_S3_PATH }}/$REPO/$PR_NUM/$RUN_NUM
              if [ $? -ne 0 ]; then
                echo "PR_ERROR_MSG=Failed to upload allure report to s3 bucket" >> $GITHUB_ENV
              fi


          - name: Generate markdown report
            id: generate_md_report
            if: ${{ env.SKIP_TESTS != 'true' && steps.generate_allure_report.outcome == 'success' || steps.archive_pod_logs.outcome == 'success' }}
            continue-on-error: true
            # It is possible for env is prepped but tests error out, the pod logs will help in debugging env issues
            run: |
              if [ -n "${{ env.PR_ERROR_MSG }}" ]; then
                echo -e "\n${{ env.PR_ERROR_MSG }}" >> output/report.md
              fi
              if [ "${{ steps.upload_allure_report.outcome }}" == "success" ]; then
                echo -e "\nPlease find the detailed integration test report [here](https://qa.planx-pla.net/dashboard/Secure/gen3-ci-reports/$REPO/$PR_NUM/$RUN_NUM/index.html)" >> output/report.md
              fi
              if [ "${{steps.archive_pod_logs.outcome}}" == "success" ]; then
                if [ ! -d output ]; then
                  mkdir output
                fi
                if [ ! -f "output/report.md" ]; then
                  touch "output/report.md"
                fi
                echo -e "\nPlease find the ci env pod logs [here]($POD_LOGS_URL)" >> output/report.md
              fi

          - name: Render report to the PR
            id: publish_md_report
            if: ${{ env.SKIP_TESTS != 'true' && steps.generate_allure_report.outcome == 'success' || steps.archive_pod_logs.outcome == 'success' }}
            continue-on-error: true  # if this fails, we still need to run clean-up steps
            run: gh pr comment $PR_NUM --body-file output/report.md -R $REPO_FN
            env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          - name: Mark workflow as failed for unsuccessful test runs
            if: ${{ env.SKIP_TESTS != 'true' && steps.run_service_tests.outcome != 'success' && steps.run_tests.outcome != 'success' }}
            run: echo "Test run was unsuccessful, marking workflow as failed" && exit 1

          - name: Stop pending jenkins jobs for cancelled run
            if: ${{ env.SKIP_TESTS != 'true' && cancelled() }}
            run: poetry run python -m gen3_ci.scripts.clean_up_jenkins
