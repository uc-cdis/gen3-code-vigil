import copy
import json
import os
import uuid

from cdislogging import get_logger
from gen3.submission import Gen3Submission
import requests

from utils import TEST_DATA_PATH


logger = get_logger(__name__, log_level=os.getenv("LOG_LEVEL", "info"))


class GraphRecord:
    def __init__(self, node_name, category, submission_order, props):
        """
        node_name: id of the node in the dictionary (example: "case")
        category: category of the node in the dictionary (example: "administrative")
        submission_order: index of this record in the submission order (example: 2)
        props: record as it should be submitted to sheepdog
        unique_id: unique "id" property returned by sheepdog when submitting a record
        indexd_guid: for *_file nodes, the guid of the referenced file in indexd
        """
        self.node_name = node_name
        # self.category = category  # not used yet
        self.submission_order = submission_order
        self.props = props
        self.unique_id = None
        # self.indexd_guid = None  # not used yet

    def __str__(self):
        return f"GraphRecord '{self.node_name}': {self.props}"


class StructuredDataTools:
    def __init__(self, auth, program_name="jnkns", project_code="jenkins"):
        self.sdk = Gen3Submission(auth_provider=auth)
        self.program_name = program_name
        self.project_code = project_code
        self.test_data_path = TEST_DATA_PATH / "structured_data"
        self.submission_order = []  # node names in the order they should be submitted
        # records as generated by data-simulator - { node name: GraphRecord }
        self.test_records = {}
        self.load_test_records()

    def create_program_and_project(self):
        logger.info(
            f"Creating program '{self.program_name}' and project '{self.project_code}'"
        )
        program_record = {
            "type": "program",
            "name": self.program_name,
            "dbgap_accession_number": self.program_name,
        }
        self.sdk.create_program(program_record)

        project_record = {
            "type": "project",
            "code": self.project_code,
            "name": self.project_code,
            "dbgap_accession_number": self.project_code,
        }
        self.sdk.create_project(self.program_name, project_record)

    def delete_all_records_in_test_project(self):
        # clean up before starting the test suite (useful when running tests locally)
        project_id = f"{self.program_name}-{self.project_code}"
        for node_name in reversed(self.submission_order):
            query = f'query {{ {node_name} (project_id: "{project_id}") {{ id }} }}'
            result = self.query(query).get("data", {}).get(node_name, [])
            for record in result:
                logger.info(
                    f"Pre-test clean up: deleting '{node_name}' record '{record['id']}'"
                )
                self.delete_record(record["id"])

    def load_test_records(self):
        lines = (self.test_data_path / "DataImportOrderPath.txt").read_text()
        for order, line in enumerate(lines.split("\n")):
            if not line:
                continue
            try:
                node_name, node_category = line.split("\t")
            except:
                print(f"Cannot parse 'DataImportOrderPath.txt' line: '{line}'")
                raise
            if node_name in ["program", "project"]:
                continue  # program and project are created separately
            self.submission_order.append(node_name)
            props = json.loads((self.test_data_path / f"{node_name}.json").read_text())
            if type(props) == list:
                if len(props) == 1:
                    props = props[0]
                else:
                    raise Exception(
                        f"Expected 1 record per test record file, but found {len(props)} in {node_name}.json"
                    )
            self.test_records[node_name] = GraphRecord(
                node_name, node_category, order, props
            )

    def submit_record(self, record, expected_status_code=200):
        try:
            result = self.sdk.submit_record(
                self.program_name, self.project_code, record.props
            )
        except requests.exceptions.HTTPError as e:
            if e.response.status_code != expected_status_code:
                logger.error(f"Error while submitting record: {e.response.text}")
                raise
        record.unique_id = result["entities"][0]["id"]
        return result

    def submit_all_test_records(self):
        for node_name in self.submission_order:
            self.submit_record(self.test_records[node_name])

    def submit_new_record(self, node_name):
        """
        Starting from a generated test data record, submit a new record with a
        new unique submitter_id.
        """
        record = copy.deepcopy(self.test_records[node_name])
        record.props["submitter_id"] = f"{node_name}_{str(uuid.uuid4())[:8]}"
        self.submit_record(record)
        return record

    def delete_record(self, unique_id, expected_status_code=200):
        if not unique_id:
            raise Exception("Unable to delete record that has no unique_id")
        return self.delete_records([unique_id], expected_status_code)

    def delete_records(self, unique_ids, expected_status_code=200):
        try:
            result = self.sdk.delete_records(
                self.program_name, self.project_code, unique_ids
            )
        except requests.exceptions.HTTPError as e:
            if e.response.status_code != expected_status_code:
                logger.error(f"Error while deleting record: {e.response.text}")
                raise
        return result

    def delete_all_test_records(self):
        to_delete = []
        for node_name in reversed(self.submission_order):
            record = self.test_records[node_name]
            if not record.unique_id:
                continue  # this record was never submitted
            to_delete.append(record.unique_id)
        self.delete_records(to_delete)

    def query(self, query_text, variables=None):
        logger.info(f"Structured data query: '{query_text}'. Variables: '{variables}'")
        return self.sdk.query(query_text, variables)

    def query_node_count(self, node_name):
        query = f"{{ _{node_name}_count }}"
        return self.query(query)
