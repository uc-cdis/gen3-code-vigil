import copy
import json
import os
import uuid

from cdislogging import get_logger
from gen3.submission import Gen3Submission
import pytest
import requests

from utils import TEST_DATA_PATH


logger = get_logger(__name__, log_level=os.getenv("LOG_LEVEL", "info"))


class GraphRecord:
    # TODO comment prop descriptions
    def __init__(self, name, category, submission_order, props):
        self.name = name
        self.category = category
        self.submission_order = submission_order
        self.props = props
        self.node_id = None
        self.indexd_guid = None

    def __str__(self):
        return f"GraphRecord '{self.name}': {self.props}"


class Sheepdog:
    def __init__(self, program_name="jnkns", project_code="jenkins"):
        # TODO gen3auth global created in conftest and passed to other classes. Can be None.
        from gen3.auth import Gen3Auth

        auth = Gen3Auth(refresh_token=pytest.api_keys["main_account"])

        self.sdk = Gen3Submission(auth_provider=auth)  # endpoint=pytest.root_url
        self.program_name = program_name
        self.project_code = project_code
        self.test_data_path = TEST_DATA_PATH / "graph_data"
        self.submission_order = []  # node names in the order they should be submitted
        # records as generated by data-simulator - { node name: GraphRecord }
        self.test_records = {}

        self.load_test_records()
        self.delete_all_records_in_test_project()

    def delete_all_records_in_test_project(self):
        # clean up before starting the test suite (useful when running tests locally)
        from services.peregrine import Peregrine

        peregrine = Peregrine()  # TODO should be global
        project_id = f"{self.program_name}-{self.project_code}"
        for node_name in reversed(self.submission_order):
            query = f'query {{ {node_name} (project_id: "{project_id}") {{ id }} }}'
            result = peregrine.query(query).get("data", {}).get(node_name, [])
            for record in result:
                logger.info(
                    f"Pre-test clean up: deleting '{node_name}' record '{record['id']}'"
                )
                self.delete_record(record["id"])

    def load_test_records(self):
        lines = (self.test_data_path / "DataImportOrderPath.txt").read_text()
        for order, line in enumerate(lines.split("\n")):
            if not line:
                continue
            try:
                node_name, node_category = line.split("\t")
            except:
                print(f"Cannot parse 'DataImportOrderPath.txt' line: '{line}'")
                raise
            if node_name in ["program", "project"]:
                continue  # program and project are created separately
            self.submission_order.append(node_name)
            props = json.loads((self.test_data_path / f"{node_name}.json").read_text())
            if type(props) == list:
                if len(props) == 1:
                    props = props[0]
                else:
                    raise Exception(
                        f"Expected 1 record per test record file, but found {len(props)} in {node_name}.json"
                    )
            self.test_records[node_name] = GraphRecord(
                node_name, node_category, order, props
            )

    def submit_record(self, record, expected_status_code=200):
        try:
            result = self.sdk.submit_record(
                self.program_name, self.project_code, record.props
            )
        except requests.exceptions.HTTPError as e:
            if e.response.status_code != expected_status_code:
                logger.error(f"Error while submitting record: {e.response.text}")
                raise
        record.node_id = result["entities"][0]["id"]
        return result

    def submit_all_test_records(self):
        for node_name in self.submission_order:
            self.submit_record(self.test_records[node_name])

    def submit_new_record(self, node_name):
        """
        Starting from a generated test data record, submit a new record with a
        new unique submitter_id.
        """
        record = copy.deepcopy(self.test_records[node_name])
        record.props["submitter_id"] = f"node_name_{uuid.uuid4()}"
        self.submit_record(record)
        return record

    def delete_record(self, record_node_id, expected_status_code=200):
        if not record_node_id:
            raise Exception("Unable to delete record that has no node_id")
        try:
            result = self.sdk.delete_record(
                self.program_name, self.project_code, record_node_id
            )
        except requests.exceptions.HTTPError as e:
            if e.response.status_code != expected_status_code:
                logger.error(f"Error while deleting record: {e.response.text}")
                raise
        return result

    def delete_all_test_records(self):
        for node_name in reversed(self.submission_order):
            record = self.test_records[node_name]
            if not record.node_id:
                continue  # this record was never submitted
            self.delete_record(record.node_id)
